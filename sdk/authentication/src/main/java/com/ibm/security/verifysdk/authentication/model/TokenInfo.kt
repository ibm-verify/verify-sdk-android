/*
 * Copyright contributors to the IBM Verify SDK for Android project
 */
@file:OptIn(ExperimentalTime::class)

package com.ibm.security.verifysdk.authentication.model

import android.os.Parcel
import android.os.Parcelable
import com.ibm.security.verifysdk.core.extension.toJsonElement
import com.ibm.security.verifysdk.core.extension.toKotlinType
import com.ibm.security.verifysdk.core.extension.toNumberOrNull
import kotlinx.parcelize.Parceler
import kotlinx.parcelize.Parcelize
import kotlinx.serialization.KSerializer
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.builtins.MapSerializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.JsonDecoder
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonEncoder
import kotlinx.serialization.json.JsonNull
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.intOrNull
import kotlinx.serialization.json.jsonPrimitive
import kotlinx.serialization.json.longOrNull
import org.json.JSONObject
import java.util.Objects
import java.util.stream.Collectors
import kotlin.time.Clock
import kotlin.time.ExperimentalTime
import kotlin.time.Instant

/**
 * The authorization server issues an access token and optional refresh token.  In addition, it
 * provides the token type and other properties supporting the access token.
 *
 * @since 3.0.0
 */
@Parcelize
@Serializable(with = TokenInfoSerializer::class)
data class TokenInfo @OptIn(ExperimentalTime::class) constructor(

    /**
     * The access token generated by the authorization server.
     */
    @SerialName("access_token")
    val accessToken: String = "",

    /**
     * The refresh token, which can be used to obtain new access tokens using the same
     * authorization grant.
     */
    @SerialName("refresh_token")
    val refreshToken: String = "",

    /**
     * The type of token that the authorization server will return which encodes the userâ€™s
     * authentication information.
     */
    @SerialName("id_token")
    val idToken: String? = null,

    /**
     * The date and time when the access token was created.
     */
    @SerialName("created_on")
    val createdOn: kotlin.time.Instant = kotlin.time.Clock.System.now(),

    /**
     *  The lifetime in seconds of the access token.
     *
     *  For example, the value "3600" denotes that the access token will expire in one hour from
     *  the time the response was generated.
     */
    @SerialName("expires_in")
    val expiresIn: Int = 0,

    /**
     * The date and time when the access token expires.
     */
    @SerialName("expires_on")
    val expiresOn: kotlin.time.Instant = kotlin.time.Clock.System.now(),

    /**
     * The scope of the access token.
     *
     * If the scope the user granted is identical to the scope the app requested, this parameter
     * is optional. If the granted scope is different from the requested scope, such as if the
     * user modified the scope, then this parameter is required.
     */
    @SerialName("scope")
    val scope: String = "",

    /**
     * Typically "Bearer" when present. Otherwise, another `tokenType` value that the client
     * has negotiated with the authorization server.
     */
    @SerialName("token_type")
    val tokenType: String = "",

    /**
     * Additional data parameters returned from the token server.
     */
    val additionalData: Map<String, Any?>
) : Parcelable {

    internal companion object : Parceler<TokenInfo> {

        override fun create(parcel: Parcel): TokenInfo {
            val accessToken = parcel.readString() ?: ""
            val refreshToken = parcel.readString() ?: ""
            val idToken = parcel.readString()
            val createdOn = Instant.fromEpochSeconds(parcel.readLong())
            val expiresIn = parcel.readInt()
            val expiresOn = Instant.fromEpochSeconds(parcel.readLong())
            val scope = parcel.readString() ?: ""
            val tokenType = parcel.readString() ?: ""

            val additionalData = HashMap<String, Any>()
            parcel.readMap(additionalData, Map::class.java.classLoader)

            return TokenInfo(
                accessToken = accessToken,
                refreshToken = refreshToken,
                idToken = idToken,
                createdOn = createdOn,
                expiresIn = expiresIn,
                expiresOn = expiresOn,
                scope = scope,
                tokenType = tokenType,
                additionalData = additionalData
            )
        }

        override fun TokenInfo.write(parcel: Parcel, flags: Int) {
            parcel.writeString(accessToken)
            parcel.writeString(refreshToken)
            parcel.writeString(idToken)
            parcel.writeLong(createdOn.epochSeconds)
            parcel.writeInt(expiresIn)
            parcel.writeLong(expiresOn.epochSeconds)
            parcel.writeString(scope)
            parcel.writeString(tokenType)
            parcel.writeMap(additionalData)
        }
    }

    /**
     * Returns a [JSONObject] representation of the token.
     *
     * @param withReadableTimestamps  flag to indicate whether the timestamp should be
     *              should be in a human readable format.
     */
    fun toJson(withReadableTimestamps: Boolean = false): JSONObject {

        val jsonString = JSONObject(Json.encodeToString(this))
        if (withReadableTimestamps) {
            jsonString.put(TokenInfoSerializer.CREATED_ON, createdOn.toString())
            jsonString.put(TokenInfoSerializer.EXPIRES_ON, expiresOn.toString())
        }

        return jsonString
    }
}

/**
 *
 * Returns `true` if a certain percentage of the lifetime has elapsed since was created. The
 * default for the lifetime is 90%.
 *
 * @param threshold  elapsed lifetime in % when the token should be refreshed
 */
@Suppress("BooleanMethodIsAlwaysInverted")
fun TokenInfo.shouldRefresh(instant: kotlin.time.Instant = kotlin.time.Clock.System.now(), threshold: Int = 90): Boolean {
    return instant.epochSeconds > createdOn.epochSeconds +
            (expiresOn.epochSeconds - createdOn.epochSeconds) * threshold / 100
}

internal object TokenInfoSerializer : KSerializer<TokenInfo> {

    private const val ACCESS_TOKEN = "accessToken"
    private const val REFRESH_TOKEN = "refreshToken"
    private const val ID_TOKEN = "idToken"
    internal const val CREATED_ON = "createdOn"
    private const val EXPIRES_IN = "expiresIn"
    internal const val EXPIRES_ON = "expiresOn"
    private const val SCOPE = "scope"
    private const val TOKEN_TYPE = "tokenType"

    private val knownKeys = setOf(
        "access_token",
        "accessToken",
        "created_on",
        "createdOn",
        "expires_in",
        "expires_on",
        "expiresIn",
        "expiresOn",
        "refresh_token",
        "refreshToken",
        "scope",
        "token_type",
        "tokenType",
        "id_token",
        "idToken",
        "version",  // ignored as attribute is not used
        "metadata"  // ignored as key is for the Metadata class and handled there
    )

    private val mapSerializerStringToJsonElement =
        MapSerializer(String.serializer(), JsonElement.serializer())

    override val descriptor: SerialDescriptor = mapSerializerStringToJsonElement.descriptor

    override fun deserialize(decoder: Decoder): TokenInfo {
        require(decoder is JsonDecoder) { "Expected JsonDecoder but got ${decoder::class.simpleName}" }
        val decoderMap = decoder.decodeSerializableValue(mapSerializerStringToJsonElement)

        val accessToken = listOf(ACCESS_TOKEN, "access_token").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.content.orEmpty()

        val refreshToken = listOf(REFRESH_TOKEN, "refresh_token").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.content.orEmpty()

        val idToken = listOf(ID_TOKEN, "id_token").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.content.orEmpty()

        val expiresIn = listOf(EXPIRES_IN, "expires_in").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.intOrNull ?: 0

        val createdOn = listOf(CREATED_ON, "created_on").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.longOrNull
            ?: (Clock.System.now().epochSeconds)

        val expiresOn = listOf(EXPIRES_ON, "expires_on").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.longOrNull
            ?: (createdOn + expiresIn)

        val scope = listOf(SCOPE).stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.content.orEmpty()

        val tokenType = listOf(TOKEN_TYPE, "token_type").stream().map(decoderMap::get)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()).getOrNull(0)?.jsonPrimitive?.content.orEmpty()
            .takeIf { it.isNotEmpty() } ?: "Bearer"

        val additionalData = decoderMap
            .filter { (key, _) -> !knownKeys.contains(key) }
            .mapValues { (_, value) -> value.toKotlinType() }

        return TokenInfo(
            accessToken, refreshToken, idToken, Instant.fromEpochSeconds(createdOn), expiresIn,
            Instant.fromEpochSeconds(expiresOn), scope, tokenType, additionalData
        )
    }

    internal fun deserializeJsonElement(element: JsonPrimitive): Any {

        if (element is JsonNull) {
            return JsonNull
        }

        if (element.isString && element.content == "null") {
            return JsonNull
        }

        element.content.lowercase()
            .toBooleanStrictOrNull()
            ?.let { return it }

        element.content.toNumberOrNull()
            ?.let { return it }

        return element.content
    }

    override fun serialize(encoder: Encoder, value: TokenInfo) {
        require(encoder is JsonEncoder) { "Expected JsonEncoder but got ${encoder::class.simpleName}" }
        val map: MutableMap<String, JsonElement> = mutableMapOf()

        map[ACCESS_TOKEN] = value.accessToken.toJsonElement()
        map[REFRESH_TOKEN] = value.refreshToken.toJsonElement()
        map[ID_TOKEN] = value.idToken.toJsonElement()
        map[CREATED_ON] = value.createdOn.epochSeconds.toJsonElement()
        map[EXPIRES_IN] = value.expiresIn.toJsonElement()
        map[EXPIRES_ON] = value.expiresOn.epochSeconds.toJsonElement()
        map[SCOPE] = value.scope.toJsonElement()
        map[TOKEN_TYPE] = value.tokenType.toJsonElement()

        value.additionalData.forEach { (key, v) ->
            map[key] = when (v) {
                null -> JsonNull
                is String -> JsonPrimitive(v)
                is Number -> JsonPrimitive(v)
                is Boolean -> JsonPrimitive(v)
                is Map<*, *> -> JsonObject((v as Map<String, Any?>).mapValues { (_, vv) -> JsonPrimitive(vv.toString()) })
                is List<*> -> JsonArray(v.map { JsonPrimitive(it.toString()) })
                else -> JsonPrimitive(v.toString())
            }
        }

        encoder.encodeSerializableValue(mapSerializerStringToJsonElement, map)
    }
}