/*
 * Copyright contributors to the IBM Verify SDK for Android project
 */

package com.ibm.security.verifysdk.mfa

import android.util.Base64
import com.ibm.security.verifysdk.authentication.model.TokenInfo
import com.ibm.security.verifysdk.core.helper.NetworkHelper
import io.ktor.client.HttpClient
import io.ktor.client.request.accept
import io.ktor.client.request.bearerAuth
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.client.request.url
import io.ktor.client.statement.bodyAsText
import io.ktor.http.ContentType
import io.ktor.http.content.TextContent
import io.ktor.http.contentType
import io.ktor.http.isSuccess
import kotlinx.serialization.InternalSerializationApi
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.buildJsonObject
import kotlinx.serialization.json.put
import java.net.URL

/**
 * An interface that defines multi-factor authentication service operations.
 *
 * This interface provides the core functionality for interacting with MFA services,
 * including transaction management, token refresh, and passwordless login operations.
 * Implementations of this interface handle the specific details for Cloud and On-Premise
 * authentication services.
 *
 * ## Usage Example
 * ```kotlin
 * val controller = MFAServiceController(authenticator)
 * val service = controller.initiate()
 *
 * // Check for pending transactions
 * service.nextTransaction().onSuccess { (transaction, count) ->
 *     transaction?.let {
 *         println("Message: ${it.message}")
 *         println("Factor ID: ${it.factorID}")
 *
 *         // Complete the transaction
 *         val factorType = authenticator.allowedFactors.first { factor ->
 *             factor.id == it.factorID
 *         }
 *         service.completeTransaction(UserAction.VERIFY, factorType)
 *     }
 * }
 * ```
 *
 * @property accessToken The access token generated by the authorization server.
 * @property refreshUri The location of the endpoint to refresh the OAuth token for the authenticator.
 * @property transactionUri The location of the endpoint to perform transaction validation.
 * @property currentPendingTransaction The current pending transaction, or null if none exists.
 * @property authenticatorId The unique identifier for the authenticator.
 *
 * @see MFAServiceController
 * @see com.ibm.security.verifysdk.mfa.api.CloudAuthenticatorService
 * @see com.ibm.security.verifysdk.mfa.api.OnPremiseAuthenticatorService
 */
interface MFAServiceDescriptor {
    val accessToken: String
    val refreshUri: URL
    val transactionUri: URL
    val currentPendingTransaction: PendingTransactionInfo?
    val authenticatorId: String

    /**
     * Refresh the OAuth token associated with the registered authenticator.
     *
     * This method obtains a new access token using the refresh token, which is necessary
     * when the current access token has expired or is about to expire.
     *
     * @param refreshToken The refresh token of the existing authenticator registration.
     * @param accountName The account name associated with the service, or null to use the existing name.
     * @param pushToken A token that identifies the device for push notifications (e.g., FCM token),
     *                  or null if push notifications are not used.
     * @param additionalData (Optional) A collection of options associated with the service.
     *                      This is primarily used for on-premise registrations.
     * @param httpClient The HTTP client to use for the request. Defaults to [NetworkHelper.getInstance].
     *
     * @return A [Result] containing either:
     *         - Success: A new [TokenInfo] with updated access and refresh tokens
     *         - Failure: An exception indicating why the refresh failed
     *
     * @see TokenInfo
     */
    suspend fun refreshToken(
        refreshToken: String,
        accountName: String?,
        pushToken: String?,
        additionalData: Map<String, Any>?,
        httpClient: HttpClient = NetworkHelper.getInstance
    ): Result<TokenInfo>

    /**
     * Retrieve the next transaction that is associated with an authenticator registration.
     *
     * When a [transactionID] is supplied, information relating to that transaction identifier
     * is returned while in a PENDING state. Otherwise, the next available transaction is returned.
     *
     * @param transactionID The transaction verification identifier, or null to get the next transaction.
     * @param httpClient The HTTP client to use for the request. Defaults to [NetworkHelper.getInstance].
     *
     * @return A [Result] containing either:
     *         - Success: A [NextTransactionInfo] with the transaction details and count of pending transactions
     *         - Failure: An exception indicating why the operation failed
     *
     * @see NextTransactionInfo
     * @see PendingTransactionInfo
     */
    suspend fun nextTransaction(
        transactionID: String? = null,
        httpClient: HttpClient = NetworkHelper.getInstance
    ): Result<NextTransactionInfo>

    /**
     * Complete a second factor authentication challenge associated with a registered authenticator.
     *
     * This method submits the user's action (approve, deny, etc.) along with the signed data
     * to complete the transaction verification process.
     *
     * @param userAction The enumerated type of user actions that can be performed to complete a transaction.
     * @param signedData The base64 encoded value using the private key associated with the factor enrollment.
     *                  This should be an empty string for actions other than [UserAction.VERIFY].
     * @param httpClient The HTTP client to use for the request. Defaults to [NetworkHelper.getInstance].
     *
     * @return A [Result] containing either:
     *         - Success: Unit indicating the transaction was completed successfully
     *         - Failure: An exception indicating why the operation failed
     *
     * @see UserAction
     */
    suspend fun completeTransaction(
        userAction: UserAction,
        signedData: String,
        httpClient: HttpClient = NetworkHelper.getInstance
    ): Result<Unit>
}

/**
 * A type alias representing the next transaction information.
 *
 * This is a pair containing:
 * - First: The [PendingTransactionInfo] for the current transaction, or null if no transaction is pending
 * - Second: The count of pending transactions associated with the authenticator
 *
 * ## Usage Example
 * ```kotlin
 * service.nextTransaction().onSuccess { (transaction, count) ->
 *     if (transaction != null) {
 *         println("Current transaction: ${transaction.message}")
 *         println("Remaining transactions: ${count - 1}")
 *     } else {
 *         println("No pending transactions")
 *     }
 * }
 * ```
 *
 * @see PendingTransactionInfo
 */
typealias NextTransactionInfo = Pair<PendingTransactionInfo?, Int>

/**
 * Performs a passwordless authentication operation.
 *
 * This extension function enables passwordless login using a QR code-based authentication flow.
 * The login endpoint and authorization code are typically obtained from scanning a QR code
 * that contains the `qrlogin_endpoint` and authorization code.
 *
 * ## Usage Example
 * ```kotlin
 * val controller = MFAServiceController(authenticator)
 * val service = controller.initiate()
 *
 * // Obtain from QR code scan
 * val loginUri = URL("https://example.com/qrlogin")
 * val authCode = "authorization-code-from-qr"
 *
 * service.login(loginUri, authCode).onSuccess {
 *     println("Passwordless login successful")
 * }.onFailure { error ->
 *     println("Login failed: ${error.message}")
 * }
 * ```
 *
 * @receiver The [MFAServiceDescriptor] instance to perform the login operation.
 * @param loginUri The endpoint that performs the passwordless login. The URL is provided as
 *                `qrlogin_endpoint` in the response data returned from a QR scan.
 * @param code The authorization code provided in the QR scan.
 * @param httpClient The HTTP client to use for the request. Defaults to [NetworkHelper.getInstance].
 *
 * @return A [Result] containing either:
 *         - Success: Unit indicating the login was successful
 *         - Failure: An exception indicating why the login failed
 *
 * @see MFAServiceDescriptor
 */
suspend fun MFAServiceDescriptor.login(
    loginUri: URL,
    code: String,
    httpClient: HttpClient = NetworkHelper.getInstance
): Result<Unit> {
    val body = buildJsonObject {
        put("lsi", code)
    }

    val decoder = Json {
        encodeDefaults = true
        explicitNulls = false
        ignoreUnknownKeys = true
    }

    return try {
        val response = httpClient.post {
            url(loginUri.toString())
            accept(ContentType.Application.Json)
            bearerAuth(accessToken)
            setBody(TextContent(body.toString(), ContentType.Application.Json))
        }

        if (response.status.isSuccess()) {
            Result.success(decoder.decodeFromString<Unit>(response.bodyAsText()))
        } else {
            Result.failure(MFAServiceError.General(response.bodyAsText()))
        }
    } catch (e: Throwable) {
        Result.failure(e)
    }
}

/**
 * Complete a second factor authentication challenge associated with a registered authenticator.
 *
 * This extension function simplifies transaction completion by automatically handling the
 * signing process using the enrolled factor's private key. It retrieves the key from the
 * Android Keystore, signs the transaction data, and submits the signed data along with
 * the user action.
 *
 * ## Usage Example
 * ```kotlin
 * val controller = MFAServiceController(authenticator)
 * val service = controller.initiate()
 *
 * // Get the next transaction
 * service.nextTransaction().onSuccess { (transaction, count) ->
 *     transaction?.let {
 *         // Find the matching factor type
 *         val factorType = authenticator.allowedFactors.first { factor ->
 *             factor.id == it.factorID
 *         }
 *
 *         // Complete the transaction with automatic signing
 *         service.completeTransaction(
 *             userAction = UserAction.VERIFY,
 *             factorType = factorType
 *         ).onSuccess {
 *             println("Transaction completed successfully")
 *         }.onFailure { error ->
 *             println("Transaction failed: ${error.message}")
 *         }
 *     }
 * }
 *
 * // Or deny the transaction (no signing required)
 * service.completeTransaction(
 *     userAction = UserAction.DENY,
 *     factorType = factorType
 * )
 * ```
 *
 * @receiver The [MFAServiceDescriptor] instance to perform the transaction completion.
 * @param userAction The enumerated type of user actions that can be performed to complete a transaction.
 *                  Defaults to [UserAction.VERIFY].
 * @param factorType The enrolled factor associated with the transaction. This is used to retrieve
 *                  the private key for signing the transaction data.
 * @param httpClient The HTTP client to use for the request. Defaults to [NetworkHelper.getInstance].
 *
 * @return A [Result] containing either:
 *         - Success: Unit indicating the transaction was completed successfully
 *         - Failure: An exception indicating why the operation failed
 *
 * @throws MFAServiceError.InvalidPendingTransaction if no pending transaction exists.
 * @throws MFAServiceError.General if the factor type is invalid for signing.
 *
 * @see MFAServiceDescriptor.completeTransaction
 * @see UserAction
 * @see FactorType
 */
@OptIn(InternalSerializationApi::class)
suspend fun MFAServiceDescriptor.completeTransaction(
    userAction: UserAction = UserAction.VERIFY,
    factorType: FactorType,
    httpClient: HttpClient = NetworkHelper.getInstance
): Result<Unit> {
    var signedData = ""
    val pendingTransaction =
        currentPendingTransaction ?: throw MFAServiceError.InvalidPendingTransaction()

    if (userAction == UserAction.VERIFY) {
        val (keyName, algorithm) = factorKeyNameAndAlgorithm(factorType)
        signedData = sign(
            keyName = keyName,
            algorithm = HashAlgorithmType.forSigning(algorithm.name),
            dataToSign = pendingTransaction.dataToSign,
            base64EncodingOptions = Base64.NO_WRAP
        )
    }

    return completeTransaction(
        userAction = userAction,
        signedData = signedData,
        httpClient = httpClient
    )
}

/**
 * Internal function to extract the key name and hash algorithm from a factor type.
 *
 * This function is used internally to retrieve the Keystore key name and signing algorithm
 * associated with a specific factor type. It supports Face, Fingerprint, and UserPresence factors.
 *
 * @param factorType The enrolled factor type to extract information from.
 *
 * @return A [Pair] containing:
 *         - First: The key name used to identify the private key in the Android Keystore
 *         - Second: The [HashAlgorithmType] used for signing operations
 *
 * @throws MFAServiceError.General if the factor type is not supported for signing operations.
 *
 * @see FactorType
 * @see HashAlgorithmType
 */
@OptIn(InternalSerializationApi::class)
internal fun factorKeyNameAndAlgorithm(factorType: FactorType): Pair<String, HashAlgorithmType> {

    return when (factorType) {
        is FactorType.Face -> Pair(factorType.value.keyName, factorType.value.algorithm)
        is FactorType.Fingerprint -> Pair(factorType.value.keyName, factorType.value.algorithm)
        is FactorType.UserPresence -> Pair(factorType.value.keyName, factorType.value.algorithm)
        else -> throw MFAServiceError.General("Invalid factor to perform signing.")
    }
}
